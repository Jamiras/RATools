using Jamiras.Components;
using RATools.Data;
using RATools.Parser.Expressions;
using RATools.Parser.Functions;
using RATools.Parser.Internal;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace RATools.Parser
{
    public interface IScriptInterpreterCallback
    {
        void UpdateProgress(int percentage, int line);
        bool IsAborted { get; }
    }

    public class AchievementScriptInterpreter
    {
        public AchievementScriptInterpreter()
        {
            _achievements = new Dictionary<Achievement, int>();
            _leaderboards = new Dictionary<Leaderboard, int>();
            _richPresence = new RichPresenceBuilder();

            _minimumVersion = RATools.Data.Version.MinimumVersion;
        }

        public RichPresenceBuilder RichPresenceBuilder
        {
            get { return _richPresence; }
        }
        private readonly RichPresenceBuilder _richPresence;

        /// <summary>
        /// Gets the achievements generated by the script.
        /// </summary>
        public IEnumerable<Achievement> Achievements
        {
            get { return _achievements.Keys; }
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly Dictionary<Achievement, int> _achievements;

        public int GetSourceLine(Achievement achievement)
        {
            return _achievements[achievement];
        }

        // for unit tests
        internal void AddAchievement(Achievement achievement)
        {
            _achievements[achievement] = 0;
        }

        /// <summary>
        /// Gets the game identifier from the script.
        /// </summary>
        public int GameId { get; private set; }

        private SoftwareVersion _minimumVersion;

        /// <summary>
        /// Gets the game title from the script.
        /// </summary>
        public string GameTitle { get; private set; }

        /// <summary>
        /// Gets the rich presence script generated by the script.
        /// </summary>
        public string RichPresence { get; internal set; }

        public int RichPresenceLine { get; private set; }

        /// <summary>
        /// Gets the leaderboards generated by the script.
        /// </summary>
        public IEnumerable<Leaderboard> Leaderboards
        {
            get { return _leaderboards.Keys; }
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly Dictionary<Leaderboard, int> _leaderboards;

        public int GetSourceLine(Leaderboard leaderboard)
        {
            return _leaderboards[leaderboard];
        }

        // for unit tests
        internal void AddLeaderboard(Leaderboard leaderboard)
        {
            _leaderboards[leaderboard] = 0;
        }

        /// <summary>
        /// Gets the serialization context of the interpreted script.
        /// </summary>
        public SerializationContext SerializationContext { get; internal set; }

        public static ExpressionGroupCollection CreateExpressionGroupCollection(IEnumerable<AchievementSet> publishedSets)
        {
            var groups = new AssetExpressionGroupCollection();
            InitializeScope(groups, publishedSets);
            return groups;
        }

        internal static InterpreterScope GetGlobalScope()
        {
            if (_globalScope == null)
            {
                _globalScope = new InterpreterScope();
                _globalScope.AddFunction(new MemoryAccessorFunction("byte", FieldSize.Byte));
                _globalScope.AddFunction(new MemoryAccessorFunction("bit0", FieldSize.Bit0));
                _globalScope.AddFunction(new MemoryAccessorFunction("bit1", FieldSize.Bit1));
                _globalScope.AddFunction(new MemoryAccessorFunction("bit2", FieldSize.Bit2));
                _globalScope.AddFunction(new MemoryAccessorFunction("bit3", FieldSize.Bit3));
                _globalScope.AddFunction(new MemoryAccessorFunction("bit4", FieldSize.Bit4));
                _globalScope.AddFunction(new MemoryAccessorFunction("bit5", FieldSize.Bit5));
                _globalScope.AddFunction(new MemoryAccessorFunction("bit6", FieldSize.Bit6));
                _globalScope.AddFunction(new MemoryAccessorFunction("bit7", FieldSize.Bit7));
                _globalScope.AddFunction(new MemoryAccessorFunction("low4", FieldSize.LowNibble));
                _globalScope.AddFunction(new MemoryAccessorFunction("high4", FieldSize.HighNibble));
                _globalScope.AddFunction(new MemoryAccessorFunction("word", FieldSize.Word));
                _globalScope.AddFunction(new MemoryAccessorFunction("tbyte", FieldSize.TByte));
                _globalScope.AddFunction(new MemoryAccessorFunction("dword", FieldSize.DWord));
                _globalScope.AddFunction(new MemoryAccessorFunction("word_be", FieldSize.BigEndianWord));
                _globalScope.AddFunction(new MemoryAccessorFunction("tbyte_be", FieldSize.BigEndianTByte));
                _globalScope.AddFunction(new MemoryAccessorFunction("dword_be", FieldSize.BigEndianDWord));
                _globalScope.AddFunction(new MemoryAccessorFunction("float", FieldSize.Float));
                _globalScope.AddFunction(new MemoryAccessorFunction("float_be", FieldSize.BigEndianFloat));
                _globalScope.AddFunction(new MemoryAccessorFunction("mbf32", FieldSize.MBF32));
                _globalScope.AddFunction(new MemoryAccessorFunction("mbf32_le", FieldSize.LittleEndianMBF32));
                _globalScope.AddFunction(new MemoryAccessorFunction("double32", FieldSize.Double32));
                _globalScope.AddFunction(new MemoryAccessorFunction("double32_be", FieldSize.BigEndianDouble32));
                _globalScope.AddFunction(new BitFunction());
                _globalScope.AddFunction(new MemoryAccessorFunction("bitcount", FieldSize.BitCount));

                _globalScope.AddFunction(new PrevPriorFunction("prev", FieldType.PreviousValue));
                _globalScope.AddFunction(new PrevPriorFunction("prior", FieldType.PriorValue));
                _globalScope.AddFunction(new PrevPriorFunction("bcd", FieldType.BinaryCodedDecimal));

                _globalScope.AddFunction(new IdentityTransformFunction());

                _globalScope.AddFunction(new OnceFunction());
                _globalScope.AddFunction(new RepeatedFunction());
                _globalScope.AddFunction(new TallyFunction());
                _globalScope.AddFunction(new DeductFunction());
                _globalScope.AddFunction(new FlagConditionFunction("never", RequirementType.ResetIf));
                _globalScope.AddFunction(new FlagConditionFunction("unless", RequirementType.PauseIf));
                _globalScope.AddFunction(new FlagConditionFunction("trigger_when", RequirementType.Trigger));
                _globalScope.AddFunction(new MeasuredFunction());
                _globalScope.AddFunction(new DisableWhenFunction());

                _globalScope.AddFunction(new AchievementSetFunction());
                _globalScope.AddFunction(new AchievementFunction());
                _globalScope.AddFunction(new LeaderboardFunction());
                _globalScope.AddFunction(new MaxOfFunction());

                _globalScope.AddFunction(new RichPresenceDisplayFunction());
                _globalScope.AddFunction(new RichPresenceConditionalDisplayFunction());
                _globalScope.AddFunction(new RichPresenceValueFunction());
                _globalScope.AddFunction(new RichPresenceMacroFunction());
                _globalScope.AddFunction(new RichPresenceLookupFunction());
                _globalScope.AddFunction(new RichPresenceAsciiStringLookupFunction());

                _globalScope.AddFunction(new AlwaysTrueFunction());
                _globalScope.AddFunction(new AlwaysFalseFunction());

                _globalScope.AddFunction(new AllOfFunction());
                _globalScope.AddFunction(new AnyOfFunction());
                _globalScope.AddFunction(new NoneOfFunction());
                _globalScope.AddFunction(new SumOfFunction());
                _globalScope.AddFunction(new TallyOfFunction());

                _globalScope.AddFunction(new RangeFunction());
                _globalScope.AddFunction(new FormatFunction());
                _globalScope.AddFunction(new LengthFunction());
                _globalScope.AddFunction(new SubstringFunction());
                _globalScope.AddFunction(new AsciiStringEqualsFunction());
                _globalScope.AddFunction(new UnicodeStringEqualsFunction());
                _globalScope.AddFunction(new ArrayPushFunction());
                _globalScope.AddFunction(new ArrayPopFunction());
                _globalScope.AddFunction(new ArrayMapFunction());
                _globalScope.AddFunction(new ArrayReduceFunction());
                _globalScope.AddFunction(new ArrayFilterFunction());
                _globalScope.AddFunction(new ArrayContainsFunction());
                _globalScope.AddFunction(new DictionaryContainsKeyFunction());
                _globalScope.AddFunction(new AssertFunction());

                _globalScope.AddFunction(new ConditionalExpression.OrNextWrapperFunction());
            }

            return _globalScope;
        }
        private static InterpreterScope _globalScope;

        /// <summary>
        /// Gets the error message generated by the script if processing failed.
        /// </summary>
        public string ErrorMessage
        {
            get
            {
                if (Error == null)
                    return null;

                var builder = new StringBuilder();
                builder.AppendFormat("{0}:{1} {2}", Error.Location.Start.Line, Error.Location.Start.Column, Error.Message);
                var error = Error.InnerError;
                while (error != null)
                {
                    builder.AppendLine();
                    builder.AppendFormat("- {0}:{1} {2}", error.Location.Start.Line, error.Location.Start.Column, error.Message);
                    error = error.InnerError;
                }
                return builder.ToString();
            }
        }

        internal ErrorExpression Error { get; private set; }

        /// <summary>
        /// Converts the provided script to a collection of expressions.
        /// </summary>
        public ExpressionGroupCollection Parse(Tokenizer input)
        {
            var expressionGroups = new AssetExpressionGroupCollection();
            expressionGroups.Parse(input);

            GameTitle = null;
            var firstGroup = expressionGroups.Groups.FirstOrDefault();
            if (firstGroup != null)
                ProcessHeaderComment(firstGroup);

            return expressionGroups;
        }

        /// <summary>
        /// Processes the provided script.
        /// </summary>
        /// <returns>
        /// <c>true</c> if the script was successfully processed, 
        /// <c>false</c> if not - in which case <see cref="ErrorMessage"/> will indicate why.
        /// </returns>
        public bool Run(Tokenizer input)
        {
            var expressionGroups = Parse(input);

            if (Error == null)
            {
                foreach (var group in expressionGroups.Groups)
                {
                    Error = group.ParseErrors.FirstOrDefault();
                    if (Error != null)
                        return false;
                }
            }

            InitializeScope(expressionGroups, null);

            return Run(expressionGroups, null);
        }

        public bool Run(ExpressionGroupCollection expressionGroups, IScriptInterpreterCallback callback = null)
        {
            var scope = expressionGroups.Scope;
            Debug.Assert(scope != null);
            var scriptContext = scope.GetContext<AchievementScriptContext>();
            Debug.Assert(scriptContext != null);

            expressionGroups.ResetErrors();

            var firstGroup = expressionGroups.Groups.FirstOrDefault();
            if (firstGroup != null)
            {
                ProcessHeaderComment(firstGroup);
                scriptContext.GameId = GameId;
                scriptContext.SerializationContext.MinimumVersion = _minimumVersion;
            }

            bool result = true;
            foreach (var expressionGroup in expressionGroups.Groups)
            {
                if (expressionGroup.NeedsEvaluated)
                {
                    if (scriptContext.Achievements == null)
                        scriptContext.Achievements = new Dictionary<Achievement, int>();
                    if (scriptContext.Leaderboards == null)
                        scriptContext.Leaderboards = new Dictionary<Leaderboard, int>();
                    if (scriptContext.RichPresence == null)
                        scriptContext.RichPresence = new RichPresenceBuilder();

                    var error = Execute(expressionGroup.Expressions, scope, callback);
                    if (error != null)
                    {
                        expressionGroups.AddEvaluationError(error);
                        result = false;
                    }

                    var assetExpressionGroup = expressionGroup as AssetExpressionGroup;
                    if (assetExpressionGroup != null)
                        assetExpressionGroup.CaptureGeneratedAssets(scriptContext);

                    expressionGroup.MarkEvaluated();
                }
            }

            if (!ReferenceEquals(scope, expressionGroups.Scope))
            {
                if (scope.FunctionCount > 0 || scope.VariableCount > 0)
                {
                    if (expressionGroups.Scope != null && !ReferenceEquals(expressionGroups.Scope, GetGlobalScope()))
                        expressionGroups.Scope.Merge(scope);
                    else
                        expressionGroups.Scope = scope;
                }
            }

            _achievements.Clear();
            _leaderboards.Clear();
            _richPresence.Clear();

            foreach (var expressionGroup in expressionGroups.Groups.OfType<AssetExpressionGroup>())
            {
                if (expressionGroup.GeneratedAchievements != null)
                {
                    foreach (var kvp in expressionGroup.GeneratedAchievements)
                        _achievements[kvp.Key] = kvp.Value;
                }

                if (expressionGroup.GeneratedLeaderboards != null)
                {
                    foreach (var kvp in expressionGroup.GeneratedLeaderboards)
                        _leaderboards[kvp.Key] = kvp.Value;
                }

                if (expressionGroup.GeneratedRichPresence != null)
                {
                    var error = _richPresence.Merge(expressionGroup.GeneratedRichPresence);
                    if (error != null)
                    {
                        expressionGroups.AddEvaluationError(error);
                        result = false;
                    }
                }
            }

            SoftwareVersion minimumVersion = scriptContext.SerializationContext.MinimumVersion.OrNewer(_minimumVersion);
            uint maxAddress = 0;

            foreach (var achievement in _achievements.Keys)
            {
                var achievementMinimumVersion = AchievementBuilder.GetMinimumVersion(achievement);
                minimumVersion = minimumVersion.OrNewer(achievementMinimumVersion);

                var achievementMaxAddress = AchievementBuilder.GetMaximumAddress(achievement);
                maxAddress = Math.Max(maxAddress, achievementMaxAddress);
            }

            foreach (var leaderboard in _leaderboards.Keys)
            {
                var leaderboardMinimumVersion = LeaderboardBuilder.GetMinimumVersion(leaderboard);
                minimumVersion = minimumVersion.OrNewer(leaderboardMinimumVersion);

                var leaderboardMaxAddress = LeaderboardBuilder.GetMaximumAddress(leaderboard);
                maxAddress = Math.Max(maxAddress, leaderboardMaxAddress);
            }

            minimumVersion = minimumVersion.OrNewer(RichPresenceBuilder.MinimumVersion());
            maxAddress = Math.Max(maxAddress, RichPresenceBuilder.MaximumAddress());

            minimumVersion = minimumVersion.OrNewer(RichPresenceBuilder.MinimumVersion());

            SerializationContext = scriptContext.SerializationContext.WithVersion(minimumVersion);
            if (maxAddress >= 0x10000)
                SerializationContext.AddressWidth = 6;
            else if (maxAddress >= 0x100)
                SerializationContext.AddressWidth = 4;
            else
                SerializationContext.AddressWidth = 2;

            if (_richPresence.IsValid)
            {
                RichPresence = _richPresence.Serialize(SerializationContext);
                RichPresenceLine = _richPresence.Line;
            }

            if (Error == null)
                Error = expressionGroups.Errors.FirstOrDefault();

            return result;
        }

        private void ProcessHeaderComment(ExpressionGroup expressionGroup)
        {
            foreach (var comment in expressionGroup.Expressions.OfType<CommentExpression>())
            {
                if (comment.Value.Contains("#ID"))
                {
                    if (GameId == 0)
                        ExtractGameId(new Token(comment.Value, 0, comment.Value.Length));
                }
                else if (comment.Value.Contains("#MinimumVersion"))
                {
                    ExtractMinimumVersion(new Token(comment.Value, 0, comment.Value.Length));
                }
                else if (GameTitle == null)
                {
                    GameTitle = comment.Value.Substring(2).Trim();
                }
            }
        }

        private void ExtractGameId(Token line)
        {
            var tokens = line.Split('=');
            if (tokens.Length > 1)
            {
                int gameId;
                if (Int32.TryParse(tokens[1].ToString(), out gameId))
                    GameId = gameId;
            }
        }

        private void ExtractMinimumVersion(Token line)
        {
            var tokens = line.Split('=');
            if (tokens.Length > 1)
            {
                SoftwareVersion version;
                if (SoftwareVersion.TryParse(tokens[1].ToString(), out version))
                    _minimumVersion = version.OrNewer(RATools.Data.Version.MinimumVersion);
            }
        }

        private static ErrorExpression Execute(ExpressionBase expression, InterpreterScope scope)
        {
            var executable = expression as IExecutableExpression;
            if (executable != null)
                return executable.Execute(scope);

            switch (expression.Type)
            {
                case ExpressionType.Comment:
                    // comments aren't actually executable, but may appear in the middle of an executable
                    // block of code. just ignore them.
                    return null;
            }

            if (scope.GetContext<FunctionCallExpression>() != null)
                return new ErrorExpression("Expression is not executable. Did you mean to return it?", expression);

            return new ErrorExpression("Only assignment statements, function calls and function definitions allowed at outer scope", expression);
        }

        internal static ErrorExpression Execute(IEnumerable<ExpressionBase> expressions, InterpreterScope scope)
        {
            foreach (var expression in expressions)
            {
                var error = Execute(expression, scope);
                if (error != null)
                    return error;

                if (scope.IsComplete)
                    break;
            }

            return null;
        }

        private static ErrorExpression Execute(IEnumerable<ExpressionBase> expressions, InterpreterScope scope, IScriptInterpreterCallback callback = null)
        {
            if (callback == null)
                return Execute(expressions, scope);

            int i = 0;
            int count = expressions.Count();

            foreach (var expression in expressions)
            {
                if (callback.IsAborted)
                    return new ErrorExpression("Processing aborted");

                int progress = (i * 100 / count);
                if (progress > 0)
                    callback.UpdateProgress(progress, expression.Location.Start.Line);
                i++;

                var error = Execute(expression, scope);
                if (error != null)
                    return error;

                if (scope.IsComplete)
                    break;
            }

            return null;
        }

        public static void InitializeScope(ExpressionGroupCollection expressionGroups, IEnumerable<AchievementSet> publishedSets)
        {
            var context = new AchievementScriptContext();
            if (publishedSets != null)
                context.Sets.AddRange(publishedSets);

            expressionGroups.Scope = new InterpreterScope(GetGlobalScope()) { Context = context };
        }
    }
}
